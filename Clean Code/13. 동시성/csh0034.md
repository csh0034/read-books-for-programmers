# 13장 동시성

## Intro
> “객체는 처리의 추상화다. 스레드는 일정의 추상화다.” - 제임스 O. 코플리 
- 동시성과 깔끔한 코드는 양립하기 어렵다.
- 스레드를 하나만 실행 하는 코드는 짜기가 쉽다. 
- 겉으로 보기에는 멀쩡해 보이는 다중 스레드코드도 짜기 쉽다. 
- 이런코드는 시스템이 부하를 받기 전까지 멀쩡 하게 돌아간다. 
- 이 장에서는 concurrent 프로그래밍의 필요성, 어려움에 대해 논한다.
- 또한, 이런 어려움에 대처하고 깨끗한 코드를작성 하는 방법도 몇 가지 제안한다.
- 마지막으로, 동시성을 테스트하는 방법과 문제점을 논한다.

## 동시성이 필요한 이유?
- 동시성은 결합을 없애는 전략이다. 즉, **무엇**과 **언제**를 분리하는 전략이다.
- 무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다.
- 구조적인 관점에서 프로그램이 작은 협력 프로그램 여럿으로 보인다.
- 따라서 시스템을 이해하기가 쉽고 문제를 분리하기도 쉽다.
- 구조적 개선만을 위해 동시성을 채택하는 건 아니다. 
- 응답 시간과 작업 처리량 개선이라는 요구사항으로 인해 사용하기도 한다.

### 미신과 오해
- 동시성은 항상 성능을 높여준다.
  - 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나
  - 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다.
- 동시성을 구현해도 설계는 변하지 않는다.
  - 단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다.
  - 일반적으로 무엇과 언제를 분리하면 시스댐 구조가 크게 달라진다.
- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.
  - 실제로는 컨테이너가 어떻게 동작하는지, 어떻게 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지를 알아야만 한다.

#### 동시성과 관련된 타당한 생각 몇 가지
- 동시성은 다소 부하를 유발한다. 성능 측면에서 부하가 걸리며 코드도 더 짜야한다.
- 동시성은 복잡하다. 간단한 문제라도 동시성은 복잡하다.
- 일반적으로 동시성 버그는 재현하기 어렵다. 그래서 진짜 결함으로 간주되지 않고 일회성 문제로 여겨 무시하기 쉽다.
- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.

## 난관
```java
// Code 1-1
public class X { 
  private int lastIdUsed;
  
  public int getNextId() {
    return ++lastIdUsed;
  }
}
```
- lastIdUsed 필드를 42로 설정한 다음， 두 스레드가 해당 인스턴스를 공유한다고 했을때
- `getNextId()`; 를 호출하면 결과는 아래 셋중 하나이다.
  - 1번 스레드는 43을 받고 2번 스레드는 44를 받는다. (lastIdUsed = 44)
  - 1번 스레드는 44를 받고 2번 스레드는 43을 받는다. (lastIdUsed = 44)
  - 1번 스레드, 2번 스레드 모두 43을 받는다. (lastIdUsed = 43)
- 대다수는 올바른 결과를 내지만, 문제는 잘못된 결과를 내놓는 일부가 존재한다는 것이다.