# 11장 시스템

## Intro
> “복잡성은 죽음이다. 개발에게서 생기를 앗아가며, 제품을 계획하고 기획하고   
> 제작하고 테스트하기 어렵게 만든다.” - 레이오지, 마이크로소프트 최소 기술 책임자

## 도시를 세운다면?
- 도시를 세운다면 혼자서는 무리이다. 각 분야를 관리하는 팀이 있기때문에 돌아간다.
- 또한 적절한 추상화와 모듈화 때문에 잘 돌아간다.
- 그러나 막상 팀이 제작하는 시스템은 비슷한 수준으로 추상화를 이뤄내지못한다.
- 깨끗한 코드를 구현하면 낮은 추상화 수준에서 관심사를 분리하기 쉬워진다.
- 이장에서는 높은 추상화 수준, 즉 **시스템** 수준에서도 깨끗함을 유지하는 방법을 살펴본다.

## 시스템의 생성과 사용을 분리하라
- 우선 제작(construction)은 사용(use)과 아주 다르다는 사실을 명심해야한다.
- 소프트웨어 시스템은 준비과정(객체생성, 의존성 연결)과 런타임 로직을 분리해야한다.
```java
// Code 1-1
public Service getService(){
  if (service == null)
    service = new MyServiceImpl(...); // 모든 상황에 적합한 기본값일까?
   return service;
}
```
- Code 1-1은 "Lazy Initialization/Evaluation(게으른 초기화)"의 일반적인 형태이다.
- 장점
  - 필요할때 까지 객체생성을 미루므로 불필요한 부하가 걸리지 않는다.
  - null 포인트를 반환하지 않는다.
- 단점
  - MyServiceImpl 생성자 인수에 명시적으로 의존한다.
  - 만약 MyServiceImpl이 무거운 객체라면 테스트를 위한 Test Double / Mock Object 를 할당해야한다.
- 초기화 지연 기법은 한번정도는 심각한 문제가 아니지만 많은 애플리케이션에서 수시로 사용한다.
- 이는 모듈성 저조와 심각한 중복을 부른다.
- 체계적이고 탄탄한 시스템을 만들고 싶다면 흔히 쓰는 좀스럽고 손쉬운 기법으로 모듈성을 깨서는 절대로 안된다.
- 설정 논리는 일반 실행 논리와 분리해야 모듈성이 높아진다.

### Main 분리
- 시스템 생성과 시스템 사용을 분리하는 한가지 방법으로, 생성과 관련한 코드는 모두 main 이나 main이 호출하는
- 모듈로 옮겨지고 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다.

### 팩토리
- 객체가 생성되는 시점을 애플리케이션에서 결정할 필요도 생긴다.
- main에서 factory 객체를 만들어서 전달하면된다. 만약 자세한 구현을 숨기고 싶다면 Abstract Factory 패턴을 사용하자.
- 생성하는 시점은 애플리케이션이 결정하지만 생성하는 코드는 모른다. (전달받은 factory 사용)\